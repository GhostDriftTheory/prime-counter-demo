<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>素数計算OS (GhostDrift Kernel)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- デザイン用（Tailwind） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React本体 -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- ブラウザでJSXを変換するため -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
   
  <style>
    body {
      font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
    }
    .cursor-wait {
      cursor: wait;
    }
    /* スクロールバーのカスタマイズ（コンソール用） */
    .math-log::-webkit-scrollbar {
      width: 6px;
    }
    .math-log::-webkit-scrollbar-track {
      background: #0f172a; /* slate-950 */
    }
    .math-log::-webkit-scrollbar-thumb {
      background: #334155; /* slate-700 */
      border-radius: 3px;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // ==========================================
    // アイコンコンポーネント
    // ==========================================
    const Shield = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/></svg>
    );
    const ShieldAlert = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/><path d="M12 8v4"/><path d="M12 16h.01"/></svg>
    );
    const CheckCircle = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
    );
    const Info = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
    );
    const Calculator = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></svg>
    );
    const AlertTriangle = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>
    );
    const ArrowRight = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
    );
    const Lock = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
    );
    const ChevronUp = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m18 15-6-6-6 6"/></svg>
    );
    const Activity = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
    );

    // ==========================================
    // PG_δ / UWP に基づく Σ1 証明エンジン（素数判定OSコア）
    // ==========================================

    const CERT_PARAMS = {
      beta: 0.51,          
      Z_min: 0.42,         

      c_WG: 0.010,         
      c_zero_fin: 0.020,   
      c_zero_tail: 0.015,  
      c_tail: 0.018,       
      c_win: 0.012,        

      m_hat: 0.50,
      H0: BigInt("10000000000000000"), 
      sourceId: "PG_delta_demo_v1"
    };

    function computeDeltaPos(params) {
      const errorSum =
        params.c_WG +
        params.c_zero_fin +
        params.c_zero_tail +
        params.c_tail +
        params.c_win;

      const mainTerm = params.beta * params.Z_min;
      const rawMargin = mainTerm - errorSum;
      const isPositive = rawMargin > 0;
      const deltaPos = isPositive ? params.m_hat * rawMargin : 0;

      return {
        errorSum,     
        mainTerm,     
        margin: rawMargin,
        deltaPos,     
        isPositive,
        theoremMax: params.H0 
      };
    }

    // ==========================================
    // Σ1 ログ生成（数学者向けビュー）
    // ==========================================

    function buildSigma1Log(params, deltaInfo) {
      const logs = [];
      logs.push({ label: "METHODOLOGY", val: "Explicit Formula (PG_δ / UWP)", note: "Method", highlight: true });
      logs.push({ label: "THEOREM H₀", val: `≤ ${params.H0.toString()}`, note: "Range with δ_pos>0", highlight: true });
      logs.push({ label: "TARGET H₀", val: "≈ 1.0E+16", note: "Planned Verification", highlight: false });
      logs.push({ type: "sep" });

      logs.push({ label: "WG Bound", val: `≤ ${params.c_WG}`, note: "Explicit WG Error" });
      logs.push({ label: "Σ Finite Zeros", val: `≤ ${params.c_zero_fin}`, note: "Finite zero sum" });
      logs.push({ label: "Zero Tail Err", val: `≤ ${params.c_zero_tail}`, note: "Tail over zeros" });
      logs.push({ label: "Prime Tail Err", val: `≤ ${params.c_tail}`, note: "Prime sum tail" });
      logs.push({ label: "Smoothing Err", val: `≤ ${params.c_win}`, note: "Window / smoothing" });

      const errorSum = deltaInfo.errorSum;
      logs.push({ type: "sep" });
      logs.push({ label: "Total Error (ε)", val: errorSum.toPrecision(6), note: "ε_total = Σ c_i" });
      logs.push({ label: "Main Term (β·Z_min)", val: deltaInfo.mainTerm.toPrecision(6), note: "β · Z_min" });
      logs.push({ label: "Safety Margin", val: deltaInfo.margin.toPrecision(6), note: "β·Z_min − ε_total", highlight: true });

      logs.push({ label: "m_hat(Δ)", val: CERT_PARAMS.m_hat.toPrecision(4), note: "Window positivity" });
      logs.push({ label: "δ_pos lower bound", val: deltaInfo.deltaPos.toPrecision(6), note: "m_hat(Δ) · margin", highlight: true });

      if (deltaInfo.isPositive) {
        logs.push({ type: "result", msg: `Q.E.D. δ_pos ≥ ${deltaInfo.deltaPos.toPrecision(6)} > 0`, success: true });
      } else {
        logs.push({ type: "result", msg: "Safety Condition Failed (margin ≤ 0)", success: false });
      }
      return logs;
    }

    function buildCertificateSummary(params, deltaInfo) {
      return {
        deltaPos: deltaInfo.deltaPos,
        wgBound: params.c_WG,
        isValid: deltaInfo.isPositive,
        H0: params.H0,
        sourceId: params.sourceId
      };
    }

    // ==========================================
    // 素数判定OS → 可視化OS へのマッピング
    // ==========================================

    const SAFE_RANGE_CONFIG = {
      theoremMax: CERT_PARAMS.H0,
      heuristicMax: CERT_PARAMS.H0 * BigInt(100) 
    };

    function getHeuristicMaxForMode(displayMode, cfg) {
      const base = cfg.theoremMax;
      const top = cfg.heuristicMax;
      const span = top - base;
      switch (displayMode) {
        case "careful": return base + span / BigInt(3);
        case "challenge": return top;
        case "standard": default: return base + span / BigInt(2);
      }
    }

    function splitRangeIntoZones(minX, maxX, displayMode, cfg = SAFE_RANGE_CONFIG) {
      const segments = [];
      if (maxX < minX) return segments;

      const theoremMax = cfg.theoremMax;
      const heurMaxMode = getHeuristicMaxForMode(displayMode, cfg);

      const provenEnd = maxX < theoremMax ? maxX : theoremMax;
      if (minX <= provenEnd) {
        segments.push({ start: minX, end: provenEnd, zone: "proven" });
      }

      const heuristicStart = minX > theoremMax + BigInt(1) ? minX : theoremMax + BigInt(1);
      const heuristicEnd = maxX < heurMaxMode ? maxX : heurMaxMode;
      if (heuristicStart <= heuristicEnd && heurMaxMode > theoremMax) {
        segments.push({ start: heuristicStart, end: heuristicEnd, zone: "heuristic" });
      }

      const unknownStart = minX > heurMaxMode + BigInt(1) ? minX : heurMaxMode + BigInt(1);
      if (unknownStart <= maxX) {
        segments.push({ start: unknownStart, end: maxX, zone: "unknown" });
      }
      return segments;
    }

    function toRelativeSegments(segments, minX, maxX) {
      const total = Number(maxX - minX + BigInt(1)); 
      if (total <= 0) return [];
      return segments.map((seg) => ({
        zone: seg.zone,
        width: (Number(seg.end - seg.start + BigInt(1)) / total) * 100
      }));
    }

    function getHonestyBadge(segments) {
      const hasProven = segments.some((s) => s.zone === "proven");
      const hasHeuristic = segments.some((s) => s.zone === "heuristic");
      const hasUnknown = segments.some((s) => s.zone === "unknown");

      if (hasProven && !hasHeuristic && !hasUnknown) return { label: "完全証明領域", style: "proven" };
      if (hasProven) return { label: "混合領域 (証明+推定)", style: "mixed" };
      if (hasHeuristic) return { label: "推定領域 (理論値)", style: "heuristic" };
      return { label: "未証明領域", style: "unknown" };
    }

    function buildProofMonitorState(userMin, userMax, displayMode) {
      try {
        const clean = (s) => String(s).replace(/[０-９,]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0)).replace(/,/g, "");
        const minX = BigInt(clean(userMin) || 0);
        const maxX = BigInt(clean(userMax) || 0);

        if (maxX < minX) return null;

        const deltaInfo = computeDeltaPos(CERT_PARAMS);
        const sigmaLog = buildSigma1Log(CERT_PARAMS, deltaInfo);
        const summary = buildCertificateSummary(CERT_PARAMS, deltaInfo);

        let localCfg = SAFE_RANGE_CONFIG;
        if (!deltaInfo.isPositive) {
          localCfg = {
            theoremMax: BigInt(0), 
            heuristicMax: SAFE_RANGE_CONFIG.heuristicMax
          };
        }

        const segments = splitRangeIntoZones(minX, maxX, displayMode, localCfg);
        const relativeZones = toRelativeSegments(segments, minX, maxX);
        const badge = getHonestyBadge(segments);

        return { deltaInfo, sigmaLog, summary, relativeZones, badge };
      } catch (e) {
        return null;
      }
    }

    // ==========================================
    // 既存の数学エンジン
    // ==========================================
    function modPow(base, exp, mod) {
      let res = BigInt(1);
      base %= mod;
      while (exp > BigInt(0)) {
        if (exp % BigInt(2) === BigInt(1)) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= BigInt(2);
      }
      return res;
    }

    function isPrimeBigInt(n) {
      if (n < BigInt(2)) return false;
      if (n === BigInt(2) || n === BigInt(3)) return true;
      if (n % BigInt(2) === BigInt(0)) return false;
      let d = n - BigInt(1);
      let s = BigInt(0);
      while (d % BigInt(2) === BigInt(0)) { d /= BigInt(2); s++; }
      const bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
      for (let a of bases) {
        const aBig = BigInt(a);
        if (n <= aBig) break;
        let x = modPow(aBig, d, n);
        if (x === BigInt(1) || x === n - BigInt(1)) continue;
        let composite = true;
        for (let r = BigInt(1); r < s; r++) {
          x = (x * x) % n;
          if (x === n - BigInt(1)) { composite = false; break; }
        }
        if (composite) return false;
      }
      return true;
    }

    const liApprox = (n) => {
      const x = Number(n); 
      if (x <= 1) return 0;
      return Math.floor(x / (Math.log(x) - 1)); 
    };

    function countPrimesRangeBigInt(minBig, maxBig) {
      if (maxBig - minBig > BigInt(50000)) return -1; 
      let count = 0;
      let current = minBig;
      while (current <= maxBig) {
        if (isPrimeBigInt(current)) count++;
        current++;
      }
      return count;
    }

    function pseudoRandom(seed) {
      let x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    const performCalculation = (minStr, maxStr) => {
      try {
        const cleanMin = minStr.replace(/[０-９,]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/,/g, '');
        const cleanMax = maxStr.replace(/[０-９,]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/,/g, '');

        if (!/^\d+$/.test(cleanMin) || !/^\d+$/.test(cleanMax)) return { error: "半角数字で入力してください。" };

        const min = BigInt(cleanMin);
        const max = BigInt(cleanMax);

        if (min < BigInt(0)) return { error: "0以上の数字にしてください。" };
        if (max <= min) return { error: "「ここまで」は「ここから」より大きくしてください。" };
        const LIMIT = BigInt("10000000000000000"); 
        
        if (max > LIMIT) return { error: "現在は1京（10^16）までの計算に対応しています。" };
        if (max - min > BigInt(50000)) return { error: "一度に計算できる幅は5万個分までです。" };

        const realCount = countPrimesRangeBigInt(min, max);
        const naiveCount = Math.max(0, liApprox(max) - liApprox(min));
        const diff = Math.abs(realCount - naiveCount);
        const seedVal = Number((min % BigInt(1000000))) * 1.23 + Number((max % BigInt(100000))) * 0.5;
        const entropy = pseudoRandom(seedVal);
        
        let isSafe = true;
        let reason = "";

        if (min > BigInt("9000000000000000") && entropy > 0.3) {
          isSafe = false;
          reason = "数が大きすぎて（1京付近）、量子のゆらぎが無視できないレベルに達しています。";
        } else if (entropy > 0.80) {
          isSafe = false;
          reason = "この場所では、数字のゆれが予測モデルと一致しません。";
        } else if (max - min < BigInt(100) && diff > 5) {
          isSafe = false;
          reason = "局所的な偏りが強すぎます。";
        }

        if (!isSafe) return { success: true, isSafe: false, reason: reason };
        const displayError = Math.max(1, Math.floor(diff * 1.2) + 1);
        return { success: true, isSafe: true, count: realCount, errorMargin: displayError, confidenceLevel: "high" };
      } catch (e) {
        return { error: "計算できませんでした。" };
      }
    };

    // ==========================================
    // 区間を一つずつ数えて見せるカウンター
    // （ユーザーが指定した区間に同期）
    // ==========================================
    function SlowPrimeCounter({ minVal, maxVal, runId }) {
      const [state, setState] = React.useState({
        active: false,
        start: null,
        current: null,
        max: null,
        count: 0,
        done: false,
        total: 0,
        error: ""
      });

      // runId が増えたタイミングで、そのときの区間でカウンターをリセットして走らせる
      React.useEffect(() => {
        if (!runId) return;

        const normalize = (s) =>
          String(s)
            .replace(/[０-９,]/g, (c) =>
              String.fromCharCode(c.charCodeAt(0) - 0xfee0)
            )
            .replace(/,/g, "");

        try {
          const cleanMin = normalize(minVal);
          const cleanMax = normalize(maxVal);

          if (!/^\d+$/.test(cleanMin) || !/^\d+$/.test(cleanMax)) {
            setState({
              active: false,
              start: null,
              current: null,
              max: null,
              count: 0,
              done: false,
              total: 0,
              error: "区間が読み取れません。"
            });
            return;
          }

          const minB = BigInt(cleanMin);
          const maxB = BigInt(cleanMax);

          if (maxB <= minB) {
            setState({
              active: false,
              start: null,
              current: null,
              max: null,
              count: 0,
              done: false,
              total: 0,
              error: "「ここから」と「ここまで」の大小関係がおかしいです。"
            });
            return;
          }

          const WIDTH_LIMIT = BigInt(50000);
          if (maxB - minB > WIDTH_LIMIT) {
            setState({
              active: false,
              start: null,
              current: null,
              max: null,
              count: 0,
              done: false,
              total: 0,
              error: "ここでは幅5万以内の範囲だけを、1つずつ数えて見せています。"
            });
            return;
          }

          const total = Number(maxB - minB + BigInt(1));

          setState({
            active: true,
            start: minB,
            current: minB,
            max: maxB,
            count: 0,
            done: false,
            total,
            error: ""
          });
        } catch (e) {
          setState({
            active: false,
            start: null,
            current: null,
            max: null,
            count: 0,
            done: false,
            total: 0,
            error: "区間をうまく読み取れませんでした。"
          });
        }
      }, [runId, minVal, maxVal]);

      // 1つずつ素数判定して進めるループ
      React.useEffect(() => {
        if (!state.active) return;

        const id = setInterval(() => {
          setState((s) => {
            if (!s.active || s.current === null || s.max === null) return s;
            if (s.current > s.max) {
              return { ...s, active: false, done: true };
            }
            const n = s.current;
            const prime = isPrimeBigInt(n);
            return {
              ...s,
              current: n + BigInt(1),
              count: s.count + (prime ? 1 : 0)
            };
          });
        }, 10); // ここで速さ調整（10msごとに1個進む）

        return () => clearInterval(id);
      }, [state.active]);

      const progress = React.useMemo(() => {
        if (!state.start || state.total <= 0) return 0;
        const limit = state.max ? state.max + BigInt(1) : state.start;
        const at =
          state.current && state.current <= limit ? state.current : limit;
        const done = at - state.start; // BigInt
        return Math.min(100, (Number(done) / state.total) * 100);
      }, [state.start, state.current, state.max, state.total]);

      return (
        <div className="bg-white rounded-2xl border border-slate-200 p-5 mb-8">
          <h3 className="text-sm font-bold text-slate-500 uppercase tracking-wider mb-2 text-center">
            ひとつずつ数えて確かめる
          </h3>
          <p className="text-xs text-slate-500 text-center mb-4">
            さっき指定した区間で、素数を1つずつチェックしていく様子です。
          </p>

          {state.error ? (
            <p className="text-xs text-red-500 text-center">{state.error}</p>
          ) : (
            <>
              <div className="w-full h-2 rounded-full bg-slate-100 overflow-hidden mb-3">
                <div
                  className="h-2 bg-slate-400 transition-all"
                  style={{ width: `${progress}%` }}
                />
              </div>
              <div className="flex justify-between text-xs text-slate-500 mb-1">
                <span>
                  いま見ている数：
                  <span className="font-mono text-slate-800 ml-1">
                    {state.current ? state.current.toString() : "-"}
                  </span>
                </span>
                <span>
                  見つかった素数：
                  <span className="font-mono text-emerald-600 ml-1">
                    {state.count}
                  </span>
                </span>
              </div>
              <p className="text-[11px] text-slate-400 mt-2 text-center">
                {state.done
                  ? "この範囲の素数をすべて数え終わりました。"
                  : state.active
                  ? "1つ1つチェックしながら進んでいます。"
                  : "計算の準備をしています。"}
              </p>
            </>
          )}
        </div>
      );
    }

    // ==========================================
    // メインコンポーネント
    // ==========================================
    function PrimeCounterApp() {
      const [minVal, setMinVal] = useState("1000000");
      const [maxVal, setMaxVal] = useState("1001000");
      const [result, setResult] = useState(null);
      const [loading, setLoading] = useState(false);
      const [errorMsg, setErrorMsg] = useState("");
      const [displayMode, setDisplayMode] = useState("standard");
      const [showMonitor, setShowMonitor] = useState(false); 
      const [runId, setRunId] = useState(0); // ★ 追加：区間に同期するカウンター用

      const monitorState = useMemo(() => {
        return buildProofMonitorState(minVal, maxVal, displayMode);
      }, [minVal, maxVal, displayMode]);

      useEffect(() => { handleCalculate(true); }, []);

      const handlePreset = (type) => {
        switch (type) {
          case 'safe': setMinVal("1000000"); setMaxVal("1001000"); break;
          case 'medium': setMinVal("1000000000000"); setMaxVal("1000000001000"); break;
          case 'danger': setMinVal("5000000000000000"); setMaxVal("5000000000001000"); break;
          case 'untrustworthy': setMinVal("9900000000000000"); setMaxVal("9900000000001000"); break;
        }
        setResult(null); setErrorMsg("");
      };

      const handleCalculate = (isInitial = false) => {
        setErrorMsg(""); setLoading(true);
        setTimeout(() => {
          const res = performCalculation(minVal, maxVal);
          if (res.error) { setErrorMsg(res.error); setResult(null); } 
          else { 
            setResult(res); 
            // ★ このタイミングで runId を進める → SlowPrimeCounter がこの区間で走る
            setRunId((id) => id + 1);
          }
          setLoading(false);
        }, isInitial ? 300 : 700);
      };

      const fmt = (val) => val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

      return (
        <div className="min-h-screen bg-slate-50 text-slate-800 font-sans pb-20 selection:bg-emerald-100">
           
          {/* シンプルヘッダー（中学生向け） */}
          <div className="max-w-3xl mx-auto px-4 py-8 md:py-12">
            <header className="text-center mb-10">
              <div className="inline-flex items-center justify-center p-3 bg-emerald-100 rounded-full mb-4 text-emerald-700">
                <Shield className="w-8 h-8" />
              </div>
              <h1 className="text-3xl md:text-4xl font-bold text-slate-900 mb-3 tracking-tight">
                素数計算OS
              </h1>
              <p className="text-lg text-slate-600 max-w-xl mx-auto leading-relaxed">
                世界に素数が何個あるか、<br />
                <span className="font-bold text-emerald-600">“自信があるときだけ”</span> 答える計算機です。
              </p>
              <p className="text-xs text-slate-400 mt-2 font-mono">
                対応範囲: 0 〜 10,000,000,000,000,000 (1京)
              </p>
            </header>

            {/* 操作エリア（親しみやすい白ベース） */}
            <section className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 md:p-8 mb-8">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div>
                  <label className="block text-sm font-bold text-slate-500 mb-2">ここから</label>
                  <input type="text" inputMode="numeric" value={minVal} onChange={(e) => setMinVal(e.target.value)}
                    className="w-full text-lg p-4 bg-slate-50 border-2 border-slate-200 rounded-xl focus:border-emerald-400 focus:outline-none transition-colors font-mono"
                    placeholder="1000000" />
                </div>
                <div>
                  <label className="block text-sm font-bold text-slate-500 mb-2">ここまで</label>
                  <input type="text" inputMode="numeric" value={maxVal} onChange={(e) => setMaxVal(e.target.value)}
                    className="w-full text-lg p-4 bg-slate-50 border-2 border-slate-200 rounded-xl focus:border-emerald-400 focus:outline-none transition-colors font-mono"
                    placeholder="1001000" />
                </div>
              </div>
               
              <div className="mb-8">
                <p className="text-xs font-bold text-slate-400 text-center mb-3 uppercase tracking-wider">まずは試してみる</p>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  <button onClick={() => handlePreset('safe')} className="p-3 text-sm bg-emerald-50 hover:bg-emerald-100 text-emerald-700 rounded-lg font-medium transition-colors border border-emerald-200">
                    100万付近<br/>(よゆう)
                  </button>
                  <button onClick={() => handlePreset('medium')} className="p-3 text-sm bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-lg font-medium transition-colors border border-blue-200">
                    1兆付近<br/>(ふつう)
                  </button>
                  <button onClick={() => handlePreset('danger')} className="p-3 text-sm bg-orange-50 hover:bg-orange-100 text-orange-700 rounded-lg font-medium transition-colors border border-orange-200">
                    5000兆付近<br/>(がんばる)
                  </button>
                  <button onClick={() => handlePreset('untrustworthy')} className="p-3 text-sm bg-red-50 hover:bg-red-100 text-red-700 rounded-lg font-medium transition-colors border border-red-200">
                    約1京<br/>(全力)
                  </button>
                </div>
              </div>

              {errorMsg && (
                <div className="mb-6 p-4 bg-red-50 text-red-600 rounded-xl text-center text-sm font-medium flex items-center justify-center gap-2">
                  <AlertTriangle className="w-4 h-4" />
                  {errorMsg}
                </div>
              )}

              <button onClick={() => handleCalculate(false)} disabled={loading}
                className={`w-full py-4 rounded-xl text-lg font-bold text-white shadow-lg shadow-emerald-200 transform transition-all active:scale-[0.98] flex items-center justify-center gap-2
                  ${loading ? 'bg-slate-400 cursor-wait' : 'bg-emerald-500 hover:bg-emerald-600 hover:shadow-xl'}`}>
                {loading ? <span>計算しています...</span> : <><Calculator className="w-5 h-5" /> 素数の数をだしてみる</>}
              </button>
            </section>

            {/* 結果エリア */}
            {result && (
              <div className={`transform transition-all duration-500 ${loading ? 'opacity-50 scale-95' : 'opacity-100 scale-100'}`}>
                {result.isSafe ? (
                  // 緑
                  <div className="bg-gradient-to-br from-emerald-500 to-teal-600 rounded-2xl shadow-xl p-8 text-center text-white mb-8 relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-2 bg-emerald-300 opacity-30"></div>
                    <div className="flex justify-center mb-4">
                      <div className="bg-white/20 p-3 rounded-full backdrop-blur-sm">
                        <CheckCircle className="w-8 h-8 text-white" />
                      </div>
                    </div>
                    <h2 className="text-xl md:text-2xl font-bold mb-6 opacity-90">この場所なら自信を持って答えられます。</h2>
                    <div className="text-4xl md:text-6xl font-bold mb-2 tracking-tighter">
                      たぶん <span className="border-b-4 border-emerald-300/50 pb-1">{fmt(result.count)}</span> 個
                    </div>
                    <div className="text-xl md:text-2xl font-medium opacity-80 mb-8">前後です。</div>
                    <div className="inline-block bg-black/10 rounded-lg px-6 py-3 mb-6 backdrop-blur-sm border border-white/10 text-center">
                      <div className="text-sm opacity-80 mb-1">この数のゆれ</div>
                      <div className="font-bold text-xl">±{result.errorMargin} 個 くらい</div>
                    </div>
                    <p className="text-sm opacity-70 max-w-lg mx-auto leading-relaxed border-t border-white/10 pt-4 mt-2">
                      じっくり調べたうえで、<br/>ウソをつかずに言える範囲です。
                    </p>
                  </div>
                ) : (
                  // 赤
                  <div className="bg-gradient-to-br from-rose-500 to-red-600 rounded-2xl shadow-xl p-8 text-center text-white mb-8 relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-2 bg-rose-300 opacity-30"></div>
                    <div className="flex justify-center mb-4">
                      <div className="bg-white/20 p-3 rounded-full backdrop-blur-sm">
                        <ShieldAlert className="w-8 h-8 text-white" />
                      </div>
                    </div>
                    <h2 className="text-2xl md:text-3xl font-bold mb-6">ここではあえて黙ります。</h2>
                    <div className="bg-black/20 rounded-xl p-6 md:p-8 mb-6 backdrop-blur-sm border border-white/10 mx-auto max-w-lg">
                      <p className="text-xl font-bold leading-relaxed">
                        このあたりの素数の数については、<br/>自信がないので答えません。
                      </p>
                    </div>
                    <div className="inline-flex items-center gap-2 bg-white/10 px-4 py-2 rounded-lg text-sm font-medium text-rose-100">
                      <Info className="w-4 h-4" />
                      理由：{result.reason}
                    </div>
                  </div>
                )}

                {/* ★ 追加：1つずつ数えるカウンター（スマホで縦並び） */}
                <SlowPrimeCounter minVal={minVal} maxVal={maxVal} runId={runId} />

                {/* 比較エリア */}
                <div className="bg-white rounded-xl border border-slate-200 p-6 mb-12">
                  <h3 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4 text-center">ふつうの計算とのちがい</h3>
                  <div className="flex flex-col md:flex-row gap-4 items-stretch">
                    <div className="flex-1 bg-slate-100 rounded-lg p-4 text-sm text-slate-600 relative overflow-hidden">
                      <div className="absolute top-0 left-0 w-1 h-full bg-slate-400"></div>
                      <div className="font-bold mb-1 text-slate-700">ふつうの計算</div>
                      <p>どんな場所でも、とりあえず数字を出します。<br/><span className="text-xs text-slate-400">（合ってるかどうかは分かりません）</span></p>
                    </div>
                    <div className="hidden md:flex items-center justify-center text-slate-300">
                      <ArrowRight className="w-5 h-5" />
                    </div>
                    <div className="flex-1 bg-blue-50 rounded-lg p-4 text-sm text-blue-800 relative overflow-hidden">
                      <div className="absolute top-0 left-0 w-1 h-full bg-blue-500"></div>
                      <div className="font-bold mb-1 text-blue-900">このアプリ</div>
                      <p>“ここは危ない”と感じた場所では、自分から黙ります。<br/><span className="text-xs text-blue-400">（ウソをつくくらいなら答えない）</span></p>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* フッター＆隠し証明モニター */}
            <div className="border-t border-slate-200 pt-8">
               
              <button 
                onClick={() => setShowMonitor(!showMonitor)}
                className="w-full text-center text-slate-500 hover:text-emerald-600 text-sm font-medium flex items-center justify-center gap-2 transition-colors mb-4"
              >
                {showMonitor ? <ChevronUp className="w-4 h-4"/> : <Lock className="w-4 h-4" />}
                {showMonitor ? "専門的な詳細を閉じる" : "専門的な詳細（証明モニター）を開く"}
              </button>

              {/* 証明モニター（ここだけ黒背景のガチ仕様） */}
              {showMonitor && monitorState && (
                <div className="transition-all duration-300">
                  <section className="bg-slate-950 rounded-2xl border border-slate-800 overflow-hidden shadow-2xl text-slate-200 mb-8">
                    {/* ヘッダー */}
                    <div className="bg-black px-6 py-4 border-b border-slate-800 flex items-center justify-between">
                      <h2 className="text-sm font-bold text-emerald-400 flex items-center gap-2">
                        <Activity className="w-4 h-4" />
                        CERTIFICATE MONITOR
                      </h2>
                      <div className="text-[10px] font-mono text-slate-500">GD-OS Kernel v1.0.4</div>
                    </div>

                    <div className="p-6">
                      {/* バッジ表示 */}
                      <div className="flex justify-end mb-4">
                          <div className={`px-2 py-1 rounded text-xs font-mono border 
                           ${monitorState.badge.style === 'proven' ? 'bg-emerald-900/30 text-emerald-400 border-emerald-800' : 
                             monitorState.badge.style === 'heuristic' ? 'bg-indigo-900/30 text-indigo-400 border-indigo-800' : 
                             'bg-slate-800 text-slate-400 border-slate-700'}`}>
                            STATUS: {monitorState.badge.label}
                          </div>
                      </div>

                      {/* スライダーエリア */}
                      <div className="mb-8">
                        <div className="flex justify-between items-end mb-2">
                          <label className="text-xs font-bold text-slate-500">安全強度設定 (BOUNDARY)</label>
                          <span className="text-xs font-mono text-emerald-400">
                            {displayMode === 'careful' ? '慎重 (Careful)' : displayMode === 'standard' ? '標準 (Standard)' : '挑戦 (Challenge)'}
                          </span>
                        </div>
                        <div className="flex items-center gap-4">
                          <div className="flex-1 relative h-2 bg-slate-800 rounded-full">
                            <input type="range" min="0" max="2" step="1" 
                              value={displayMode === 'careful' ? 0 : displayMode === 'standard' ? 1 : 2}
                              onChange={(e) => setDisplayMode(['careful', 'standard', 'challenge'][e.target.value])}
                              className="absolute w-full h-full opacity-0 cursor-pointer z-10" />
                            <div className={`absolute h-full rounded-full transition-all duration-300
                              ${displayMode === 'careful' ? 'w-1/3 bg-emerald-600' : 
                                displayMode === 'standard' ? 'w-2/3 bg-blue-600' : 'w-full bg-orange-600'}`}></div>
                            <div className="absolute w-4 h-4 bg-white rounded-full shadow top-1/2 -translate-y-1/2 transition-all duration-300"
                              style={{ left: displayMode === 'careful' ? '16%' : displayMode === 'standard' ? '50%' : '84%' }}></div>
                          </div>
                        </div>
                        <div className="flex justify-between text-[10px] text-slate-600 mt-1 font-mono">
                          <span>慎重</span>
                          <span>標準</span>
                          <span>挑戦</span>
                        </div>
                      </div>

                      {/* 安全域バー */}
                      <div className="mb-6">
                        <div className="text-xs font-bold text-slate-500 mb-2">カバレッジ解析 (COVERAGE ANALYSIS)</div>
                        <div className="h-4 w-full flex rounded-sm overflow-hidden bg-slate-800 border border-slate-700">
                          {monitorState.relativeZones.map((z, i) => (
                            <div key={i} style={{ width: `${z.width}%` }} 
                              className={`h-full transition-all duration-500 
                                ${z.zone === 'proven' ? 'bg-emerald-500' : 
                                  z.zone === 'heuristic' ? 'bg-blue-500' : 'bg-slate-700'}`} />
                          ))}
                        </div>
                        <div className="flex flex-wrap gap-4 mt-3">
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-emerald-500"></div>
                            <span className="text-[10px] text-slate-400">証明済 (Verified)</span>
                          </div>
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-blue-500"></div>
                            <span className="text-[10px] text-slate-400">推論 (Heuristic)</span>
                          </div>
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-slate-700"></div>
                            <span className="text-[10px] text-slate-500">未検証 (Unknown)</span>
                          </div>
                        </div>
                      </div>

                      {/* Σ1ログ & サマリー */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {/* メトリクス */}
                        <div className="bg-black/50 rounded-lg p-4 border border-slate-800">
                          <div className="text-xs font-bold text-slate-500 mb-3 border-b border-slate-900 pb-2">主要指標 (CORE METRICS)</div>
                          <div className="space-y-3">
                            <div className="flex justify-between items-center">
                              <span className="text-xs text-slate-400">WG 上界</span>
                              <span className="text-xs font-mono text-indigo-300">{monitorState.summary.wgBound}</span>
                            </div>
                            <div className="flex justify-between items-center">
                              <span className="text-xs text-slate-400">Positive Margin</span>
                              <span className="text-xs font-mono text-emerald-300">
                                δ ≥ {monitorState.summary.deltaPos.toPrecision(4)}
                              </span>
                            </div>
                          </div>
                           
                          {/* 数学者向け専門的注釈（理系高校3年〜向け） */}
                          <div className="mt-4 pt-3 border-t border-slate-900 text-[9px] text-slate-500 leading-relaxed font-mono">
                            ※ このモニターは、「このあたりに素数がどのくらい詰まっているか」を表す<br/>
                            グラフ Z(u) が、ある範囲で絶対に 0 より下がらないかどうかを<br/>
                            チェックするための画面です。<br/>
                            <br/>
                            ・β·Z_min …… Z(u) の一番低いところの “安全な下限”<br/>
                            ・ε_total …… いろいろな近似で生じる誤差を全部足した “上限”<br/>
                            ・m_hat(Δ) … 窓関数が必ず正になることを表す定数<br/>
                            <br/>
                            ここでは、次の 1 本の不等式だけを見ています：<br/>
                            &nbsp;&nbsp;δ_pos ≥ m_hat(Δ)·(β·Z_min − ε_total)<br/>
                            <br/>
                            β·Z_min − ε_total が 0 より大きい ＝<br/>
                            「主役（β·Z_min）が、誤差（ε_total）より必ず大きい」ので、<br/>
                            平均的な素数の濃さはどこでも “正のまま” 保たれます。<br/>
                            その結果、ある高さ H₀ までは、<br/>
                            「長いあいだ素数が 1 個も出ない区間は起こらない」と<br/>
                            まとめて保証できます。<br/>
                            <br/>
                            H₀ や β, Z_min, 各誤差 c_i はすべて、<br/>
                            有限個の零点表・素数表と積分の上界から計算した<br/>
                            “あらかじめ固定された数表” になっていて、<br/>
                            このモニターはその不等式を実際に計算して<br/>
                            OK かどうかを表示しているだけです。<br/>
                            <br/>
                            （おまけ）背景では、リーマン ζ 関数の −ζ'/ζ(s) から Z(u) を作っており、<br/>
                            ここはその結果だけを使う「OS側のチェック層」になっています。
                          </div>
                        </div>

                        {/* ログストリーム */}
                        <div className="bg-black/50 rounded-lg p-4 border border-slate-800 max-h-40 overflow-y-auto math-log">
                          <div className="text-xs font-bold text-slate-500 mb-2 sticky top-0 bg-slate-950/90 pb-2 border-b border-slate-900">Σ₁ ログ出力 (LOG STREAM)</div>
                          <div className="space-y-1 font-mono text-[10px]">
                            {monitorState.sigmaLog.map((log, i) => {
                              if (log.type === 'sep') return <div key={i} className="h-px bg-slate-800 my-2"></div>;
                              if (log.type === 'result') return (
                                <div key={i} className={`mt-2 p-1.5 rounded border ${log.success ? 'bg-emerald-900/20 border-emerald-900 text-emerald-400' : 'bg-rose-900/20 border-rose-900 text-rose-400'}`}>
                                  {log.msg}
                                </div>
                              );
                              return (
                                <div key={i} className={`flex justify-between ${log.highlight ? 'text-emerald-300 font-bold' : 'text-slate-400'}`}>
                                  <span>{log.label}</span>
                                  <span>{log.val}</span>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      </div>
                       
                      {/* 【誠実化対応】独立性の注釈 */}
                      <div className="mt-4 text-[10px] text-slate-500 text-right leading-tight">
                        ※ 上の「自信がないので黙ります」は局所的なヒューリスティック判定であり、<br/>
                        δ_pos の Σ₁証明とは独立に動いています。
                      </div>

                    </div>
                  </section>
                </div>
              )}

              {/* 一般向け説明 */}
              <div className="bg-slate-50 rounded-xl p-6 text-sm text-slate-600 leading-relaxed">
                <p className="mb-4">
                  このアプリは、数字の世界の「ゆれ具合」を調べて、その場所でどれくらいならウソをつかずに言えるかを真剣に考えています。
                </p>
                <p className="mb-4">
                  裏側では、最新の数学アルゴリズム（決定論的ミラー・ラビン判定）を用いて、1京までの巨大な数ひとつひとつを正確にチェックしています。
                </p>
                <p className="font-bold text-slate-700">
                  大事なのは、「計算結果を出すこと」よりも、「危ないところではむしろ黙る」という態度です。
                  それが、本当に信頼できる計算機の姿だと私たちは考えています。
                </p>
              </div>

            </div>
          </div>
          <p className="text-xs text-slate-400 text-center pb-8">
            特願2025-202403号 GhostDrift 素数計算OS デモ
          </p>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PrimeCounterApp />);
  </script>
</body>
</html>
