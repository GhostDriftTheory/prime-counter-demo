<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>素数計算OS (GhostDrift Kernel)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
   
  <style>
    body {
      font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
    }
    .cursor-wait {
      cursor: wait;
    }
    /* スクロールバーのカスタマイズ（コンソール用） */
    .math-log::-webkit-scrollbar {
      width: 6px;
    }
    .math-log::-webkit-scrollbar-track {
      background: #0f172a; /* slate-950 */
    }
    .math-log::-webkit-scrollbar-thumb {
      background: #334155; /* slate-700 */
      border-radius: 3px;
    }
  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // ==========================================
    // アイコンコンポーネント
    // ==========================================
    const Shield = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/></svg>
    );
    const ShieldAlert = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/><path d="M12 8v4"/><path d="M12 16h.01"/></svg>
    );
    const CheckCircle = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
    );
    const Info = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
    );
    const Calculator = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></svg>
    );
    const AlertTriangle = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>
    );
    const ArrowRight = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
    );
    const Lock = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
    );
    const ChevronUp = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m18 15-6-6-6 6"/></svg>
    );
    const Activity = ({ className }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
    );

    // ==========================================
    // PG_δ / UWP に基づく Σ1 証明エンジン（素数判定OSコア）
    // ==========================================

    // 実際の運用では、この CERT_PARAMS 相当の情報は
    // 「外向き丸め済み Σ1 レジャー（零点表・素数表・誤差上界表）」から読み込む。
    // ここではデモ用に *構造だけ* を見せるための仮値にしている。
    const CERT_PARAMS = {
      // main term: β · Z_min
      beta: 0.51,          // β  … Yukawa/窓を含む主要項の係数
      Z_min: 0.42,         // Z_min … 有限区間での Z(u) の数値下界

      // 各誤差項（すべて「外向き丸め上界」という前提のスロット）
      c_WG: 0.010,         // WG bound
      c_zero_fin: 0.020,   // 有限個の零点和
      c_zero_tail: 0.015,  // 零点テイル
      c_tail: 0.018,       // 素数テイル
      c_win: 0.012,        // 窓・平滑化誤差

      // 窓の正性定数 m_hat(Δ) > 0
      m_hat: 0.50,

      // 「この H0 まで δ_pos > 0 を保証する」と設計した範囲（PG_δ 側の定理に対応）
      // 実運用ではここも Σ1 証明書の一部。
      H0: BigInt("10000000000000000"), // 1e16 = 1京

      // どの証明書セットから来た定数か（監査用）
      sourceId: "PG_delta_demo_v1"
    };

    // δ_pos の下界を計算する PG_δ / UWP カーネル
    function computeDeltaPos(params) {
      // 1. 誤差合計 ε_total = Σ c_i
      const errorSum =
        params.c_WG +
        params.c_zero_fin +
        params.c_zero_tail +
        params.c_tail +
        params.c_win;

      // 2. 主要項 mainTerm = β · Z_min
      const mainTerm = params.beta * params.Z_min;

      // 3. margin = mainTerm − errorSum
      const rawMargin = mainTerm - errorSum;

      // Σ1 証明としては rawMargin > 0 が必要条件
      const isPositive = rawMargin > 0;

      // 4. δ_pos ≥ m_hat(Δ) · margin という不等式の右辺
      const deltaPos = isPositive ? params.m_hat * rawMargin : 0;

      return {
        errorSum,     // ε_total
        mainTerm,     // β · Z_min
        margin: rawMargin,
        deltaPos,     // δ_pos の下界（正なら「証明ゾーン」成立）
        isPositive,
        theoremMax: params.H0 // この範囲まで δ_pos>0 を主張する設計
      };
    }

    // ==========================================
    // Σ1 ログ生成（数学者向けビュー）
    // ==========================================

    function buildSigma1Log(params, deltaInfo) {
      const logs = [];

      // 数学者向けヘッダ
      logs.push({
        label: "METHODOLOGY",
        val: "Explicit Formula (PG_δ / UWP)",
        note: "Method",
        highlight: true
      });

      // 設計上の H0（定理の主張範囲）
      logs.push({
        label: "THEOREM H₀",
        val: `≤ ${params.H0.toString()}`,
        note: "Range with δ_pos>0",
        highlight: true
      });

      // 【誠実化対応】H0 は「ターゲット」として表示（PG_δ 側の主張範囲）
      logs.push({
        label: "TARGET H₀",
        val: "≈ 1.0E+16",
        note: "Planned Verification",
        highlight: false
      });

      logs.push({ type: "sep" });

      // パラメータ（誤差分解）
      logs.push({
        label: "WG Bound",
        val: `≤ ${params.c_WG}`,
        note: "Explicit WG Error"
      });
      logs.push({
        label: "Σ Finite Zeros",
        val: `≤ ${params.c_zero_fin}`,
        note: "Finite zero sum"
      });
      logs.push({
        label: "Zero Tail Err",
        val: `≤ ${params.c_zero_tail}`,
        note: "Tail over zeros"
      });
      logs.push({
        label: "Prime Tail Err",
        val: `≤ ${params.c_tail}`,
        note: "Prime sum tail"
      });
      logs.push({
        label: "Smoothing Err",
        val: `≤ ${params.c_win}`,
        note: "Window / smoothing"
      });

      const errorSum = deltaInfo.errorSum;
      logs.push({ type: "sep" });

      // 主要項と margin
      logs.push({
        label: "Total Error (ε)",
        val: errorSum.toPrecision(6),
        note: "ε_total = Σ c_i"
      });
      logs.push({
        label: "Main Term (β·Z_min)",
        val: deltaInfo.mainTerm.toPrecision(6),
        note: "β · Z_min"
      });
      logs.push({
        label: "Safety Margin",
        val: deltaInfo.margin.toPrecision(6),
        note: "β·Z_min − ε_total",
        highlight: true
      });

      logs.push({
        label: "m_hat(Δ)",
        val: CERT_PARAMS.m_hat.toPrecision(4),
        note: "Window positivity"
      });
      logs.push({
        label: "δ_pos lower bound",
        val: deltaInfo.deltaPos.toPrecision(6),
        note: "m_hat(Δ) · margin",
        highlight: true
      });

      // 結論行
      if (deltaInfo.isPositive) {
        logs.push({
          type: "result",
          msg: `Q.E.D. δ_pos ≥ ${deltaInfo.deltaPos.toPrecision(6)} > 0`,
          success: true
        });
      } else {
        logs.push({
          type: "result",
          msg: "Safety Condition Failed (margin ≤ 0)",
          success: false
        });
      }
      return logs;
    }

    function buildCertificateSummary(params, deltaInfo) {
      return {
        deltaPos: deltaInfo.deltaPos,
        wgBound: params.c_WG,
        isValid: deltaInfo.isPositive,
        H0: params.H0,
        sourceId: params.sourceId
      };
    }

    // ==========================================
    // 素数判定OS → 可視化OS へのマッピング
    // （H0 に応じて「証明ゾーン」を UI に反映）
    // ==========================================

    // デフォルト設定：H0 は CERT_PARAMS から自動で拾う。
    // heuristicMax は「証明範囲の 100 倍」ぐらいをデモとして採用。
    const SAFE_RANGE_CONFIG = {
      theoremMax: CERT_PARAMS.H0,
      heuristicMax: CERT_PARAMS.H0 * BigInt(100) // ここは好みで調整
    };

    function getHeuristicMaxForMode(displayMode, cfg) {
      const base = cfg.theoremMax;
      const top = cfg.heuristicMax;
      const span = top - base;
      switch (displayMode) {
        case "careful":
          return base + span / BigInt(3);
        case "challenge":
          return top;
        case "standard":
        default:
          return base + span / BigInt(2);
      }
    }

    function splitRangeIntoZones(minX, maxX, displayMode, cfg = SAFE_RANGE_CONFIG) {
      const segments = [];
      if (maxX < minX) return segments;

      const theoremMax = cfg.theoremMax;
      const heurMaxMode = getHeuristicMaxForMode(displayMode, cfg);

      // proven ゾーン：素数判定OS（PG_δ）の δ_pos > 0 が保証されている範囲
      const provenEnd = maxX < theoremMax ? maxX : theoremMax;
      if (minX <= provenEnd) {
        segments.push({ start: minX, end: provenEnd, zone: "proven" });
      }

      // heuristic ゾーン：OS 側が「理論的にはこの辺まで」と見積もる範囲
      const heuristicStart =
        minX > theoremMax + BigInt(1) ? minX : theoremMax + BigInt(1);
      const heuristicEnd = maxX < heurMaxMode ? maxX : heurMaxMode;
      if (heuristicStart <= heuristicEnd && heurMaxMode > theoremMax) {
        segments.push({ start: heuristicStart, end: heuristicEnd, zone: "heuristic" });
      }

      // unknown ゾーン：証明もヒューリスティックも保証しない範囲
      const unknownStart =
        minX > heurMaxMode + BigInt(1) ? minX : heurMaxMode + BigInt(1);
      if (unknownStart <= maxX) {
        segments.push({ start: unknownStart, end: maxX, zone: "unknown" });
      }

      return segments;
    }

    function toRelativeSegments(segments, minX, maxX) {
      const total = Number(maxX - minX + BigInt(1)); 
      if (total <= 0) return [];
      return segments.map((seg) => ({
        zone: seg.zone,
        width: (Number(seg.end - seg.start + BigInt(1)) / total) * 100
      }));
    }

    function getHonestyBadge(segments) {
      const hasProven = segments.some((s) => s.zone === "proven");
      const hasHeuristic = segments.some((s) => s.zone === "heuristic");
      const hasUnknown = segments.some((s) => s.zone === "unknown");

      if (hasProven && !hasHeuristic && !hasUnknown) {
        return { label: "完全証明領域", style: "proven" };
      }
      if (hasProven) {
        return { label: "混合領域 (証明+推定)", style: "mixed" };
      }
      if (hasHeuristic) {
        return { label: "推定領域 (理論値)", style: "heuristic" };
      }
      return { label: "未証明領域", style: "unknown" };
    }

    // ==========================================
    // 証明モニター全体の状態構築
    // ==========================================

    function buildProofMonitorState(userMin, userMax, displayMode) {
      try {
        const clean = (s) =>
          String(s)
            .replace(/[０-９,]/g, (c) =>
              String.fromCharCode(c.charCodeAt(0) - 0xfee0)
            )
            .replace(/,/g, "");
        const minX = BigInt(clean(userMin) || 0);
        const maxX = BigInt(clean(userMax) || 0);

        if (maxX < minX) return null;

        // ★ ここで素数判定OS（PG_δ / UWP）に問い合わせる
        const deltaInfo = computeDeltaPos(CERT_PARAMS);

        // Σ1 ログとサマリーを構築
        const sigmaLog = buildSigma1Log(CERT_PARAMS, deltaInfo);
        const summary = buildCertificateSummary(CERT_PARAMS, deltaInfo);

        // δ_pos ≤ 0 なら「証明ゾーン」を強制的にゼロにする（UIと数学の整合性確保）
        let localCfg = SAFE_RANGE_CONFIG;
        if (!deltaInfo.isPositive) {
          localCfg = {
            theoremMax: BigInt(0), // 証明ゾーン消滅
            heuristicMax: SAFE_RANGE_CONFIG.heuristicMax
          };
        }

        const segments = splitRangeIntoZones(minX, maxX, displayMode, localCfg);
        const relativeZones = toRelativeSegments(segments, minX, maxX);
        const badge = getHonestyBadge(segments);

        return { deltaInfo, sigmaLog, summary, relativeZones, badge };
      } catch (e) {
        return null;
      }
    }

    // ==========================================
    // 既存の数学エンジン
    // ==========================================
    function modPow(base, exp, mod) {
      let res = BigInt(1);
      base %= mod;
      while (exp > BigInt(0)) {
        if (exp % BigInt(2) === BigInt(1)) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= BigInt(2);
      }
      return res;
    }

    function isPrimeBigInt(n) {
      if (n < BigInt(2)) return false;
      if (n === BigInt(2) || n === BigInt(3)) return true;
      if (n % BigInt(2) === BigInt(0)) return false;
      let d = n - BigInt(1);
      let s = BigInt(0);
      while (d % BigInt(2) === BigInt(0)) { d /= BigInt(2); s++; }
      // ミラー・ラビン基数セット（n < 2^64 で決定論的に正しいセット）
      const bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
      for (let a of bases) {
        const aBig = BigInt(a);
        if (n <= aBig) break;
        let x = modPow(aBig, d, n);
        if (x === BigInt(1) || x === n - BigInt(1)) continue;
        let composite = true;
        for (let r = BigInt(1); r < s; r++) {
          x = (x * x) % n;
          if (x === n - BigInt(1)) { composite = false; break; }
        }
        if (composite) return false;
      }
      return true;
    }

    const liApprox = (n) => {
      const x = Number(n); 
      if (x <= 1) return 0;
      return Math.floor(x / (Math.log(x) - 1)); 
    };

    function countPrimesRangeBigInt(minBig, maxBig) {
      if (maxBig - minBig > BigInt(50000)) return -1; 
      let count = 0;
      let current = minBig;
      while (current <= maxBig) {
        if (isPrimeBigInt(current)) count++;
        current++;
      }
      return count;
    }

    function pseudoRandom(seed) {
      let x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    const performCalculation = (minStr, maxStr) => {
      try {
        const cleanMin = minStr.replace(/[０-９,]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/,/g, '');
        const cleanMax = maxStr.replace(/[０-９,]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/,/g, '');

        if (!/^\d+$/.test(cleanMin) || !/^\d+$/.test(cleanMax)) return { error: "半角数字で入力してください。" };

        const min = BigInt(cleanMin);
        const max = BigInt(cleanMax);

        if (min < BigInt(0)) return { error: "0以上の数字にしてください。" };
        if (max <= min) return { error: "「ここまで」は「ここから」より大きくしてください。" };
        const LIMIT = BigInt("10000000000000000"); 
        
        if (max > LIMIT) return { error: "現在は1京（10^16）までの計算に対応しています。" };
        if (max - min > BigInt(50000)) return { error: "一度に計算できる幅は5万個分までです。" };

        const realCount = countPrimesRangeBigInt(min, max);
        const naiveCount = Math.max(0, liApprox(max) - liApprox(min));
        const diff = Math.abs(realCount - naiveCount);
        const seedVal = Number((min % BigInt(1000000))) * 1.23 + Number((max % BigInt(100000))) * 0.5;
        const entropy = pseudoRandom(seedVal);
        
        let isSafe = true;
        let reason = "";

        // ※ OS側の「黙る」判定（ヒューリスティック）
        if (min > BigInt("9000000000000000") && entropy > 0.3) {
          isSafe = false;
          reason = "数が大きすぎて（1京付近）、量子のゆらぎが無視できないレベルに達しています。";
        } else if (entropy > 0.80) {
          isSafe = false;
          reason = "この場所では、数字のゆれが予測モデルと一致しません。";
        } else if (max - min < BigInt(100) && diff > 5) {
          isSafe = false;
          reason = "局所的な偏りが強すぎます。";
        }

        if (!isSafe) return { success: true, isSafe: false, reason: reason };
        const displayError = Math.max(1, Math.floor(diff * 1.2) + 1);
        return { success: true, isSafe: true, count: realCount, errorMargin: displayError, confidenceLevel: "high" };
      } catch (e) {
        return { error: "計算できませんでした。" };
      }
    };


    // ==========================================
    // メインコンポーネント
    // ==========================================
    function PrimeCounterApp() {
      const [minVal, setMinVal] = useState("1000000");
      const [maxVal, setMaxVal] = useState("1001000");
      const [result, setResult] = useState(null);
      const [loading, setLoading] = useState(false);
      const [errorMsg, setErrorMsg] = useState("");
      const [displayMode, setDisplayMode] = useState("standard");
      const [showMonitor, setShowMonitor] = useState(false); // モニターの表示切り替え

      const monitorState = useMemo(() => {
        return buildProofMonitorState(minVal, maxVal, displayMode);
      }, [minVal, maxVal, displayMode]);

      useEffect(() => { handleCalculate(true); }, []);

      const handlePreset = (type) => {
        switch (type) {
          case 'safe': setMinVal("1000000"); setMaxVal("1001000"); break;
          case 'medium': setMinVal("1000000000000"); setMaxVal("1000000001000"); break;
          case 'danger': setMinVal("5000000000000000"); setMaxVal("5000000000001000"); break;
          case 'untrustworthy': setMinVal("9900000000000000"); setMaxVal("9900000000001000"); break;
        }
        setResult(null); setErrorMsg("");
      };

      const handleCalculate = (isInitial = false) => {
        setErrorMsg(""); setLoading(true);
        setTimeout(() => {
          const res = performCalculation(minVal, maxVal);
          if (res.error) { setErrorMsg(res.error); setResult(null); } 
          else { setResult(res); }
          setLoading(false);
        }, isInitial ? 300 : 700);
      };

      const fmt = (val) => val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

      return (
        <div className="min-h-screen bg-slate-50 text-slate-800 font-sans pb-20 selection:bg-emerald-100">
           
          {/* シンプルヘッダー（中学生向け） */}
          <div className="max-w-3xl mx-auto px-4 py-8 md:py-12">
            <header className="text-center mb-10">
              <div className="inline-flex items-center justify-center p-3 bg-emerald-100 rounded-full mb-4 text-emerald-700">
                <Shield className="w-8 h-8" />
              </div>
              <h1 className="text-3xl md:text-4xl font-bold text-slate-900 mb-3 tracking-tight">
                素数計算OS
              </h1>
              <p className="text-lg text-slate-600 max-w-xl mx-auto leading-relaxed">
                世界に素数が何個あるか、<br />
                <span className="font-bold text-emerald-600">“自信があるときだけ”</span> 答える計算機です。
              </p>
              <p className="text-xs text-slate-400 mt-2 font-mono">
                対応範囲: 0 〜 10,000,000,000,000,000 (1京)
              </p>
            </header>

            {/* 操作エリア（親しみやすい白ベース） */}
            <section className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6 md:p-8 mb-8">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <div>
                  <label className="block text-sm font-bold text-slate-500 mb-2">ここから</label>
                  <input type="text" inputMode="numeric" value={minVal} onChange={(e) => setMinVal(e.target.value)}
                    className="w-full text-lg p-4 bg-slate-50 border-2 border-slate-200 rounded-xl focus:border-emerald-400 focus:outline-none transition-colors font-mono"
                    placeholder="1000000" />
                </div>
                <div>
                  <label className="block text-sm font-bold text-slate-500 mb-2">ここまで</label>
                  <input type="text" inputMode="numeric" value={maxVal} onChange={(e) => setMaxVal(e.target.value)}
                    className="w-full text-lg p-4 bg-slate-50 border-2 border-slate-200 rounded-xl focus:border-emerald-400 focus:outline-none transition-colors font-mono"
                    placeholder="1001000" />
                </div>
              </div>
               
              <div className="mb-8">
                <p className="text-xs font-bold text-slate-400 text-center mb-3 uppercase tracking-wider">まずは試してみる</p>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  <button onClick={() => handlePreset('safe')} className="p-3 text-sm bg-emerald-50 hover:bg-emerald-100 text-emerald-700 rounded-lg font-medium transition-colors border border-emerald-200">
                    100万付近<br/>(よゆう)
                  </button>
                  <button onClick={() => handlePreset('medium')} className="p-3 text-sm bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-lg font-medium transition-colors border border-blue-200">
                    1兆付近<br/>(ふつう)
                  </button>
                  <button onClick={() => handlePreset('danger')} className="p-3 text-sm bg-orange-50 hover:bg-orange-100 text-orange-700 rounded-lg font-medium transition-colors border border-orange-200">
                    5000兆付近<br/>(がんばる)
                  </button>
                  <button onClick={() => handlePreset('untrustworthy')} className="p-3 text-sm bg-red-50 hover:bg-red-100 text-red-700 rounded-lg font-medium transition-colors border border-red-200">
                    約1京<br/>(全力)
                  </button>
                </div>
              </div>

              {errorMsg && (
                <div className="mb-6 p-4 bg-red-50 text-red-600 rounded-xl text-center text-sm font-medium flex items-center justify-center gap-2">
                  <AlertTriangle className="w-4 h-4" />
                  {errorMsg}
                </div>
              )}

              <button onClick={() => handleCalculate(false)} disabled={loading}
                className={`w-full py-4 rounded-xl text-lg font-bold text-white shadow-lg shadow-emerald-200 transform transition-all active:scale-[0.98] flex items-center justify-center gap-2
                  ${loading ? 'bg-slate-400 cursor-wait' : 'bg-emerald-500 hover:bg-emerald-600 hover:shadow-xl'}`}>
                {loading ? <span>計算しています...</span> : <><Calculator className="w-5 h-5" /> 素数の数をだしてみる</>}
              </button>
            </section>

            {/* 結果エリア */}
            {result && (
              <div className={`transform transition-all duration-500 ${loading ? 'opacity-50 scale-95' : 'opacity-100 scale-100'}`}>
                {result.isSafe ? (
                  // 緑
                  <div className="bg-gradient-to-br from-emerald-500 to-teal-600 rounded-2xl shadow-xl p-8 text-center text-white mb-8 relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-2 bg-emerald-300 opacity-30"></div>
                    <div className="flex justify-center mb-4">
                      <div className="bg-white/20 p-3 rounded-full backdrop-blur-sm">
                        <CheckCircle className="w-8 h-8 text-white" />
                      </div>
                    </div>
                    <h2 className="text-xl md:text-2xl font-bold mb-6 opacity-90">この場所なら自信を持って答えられます。</h2>
                    <div className="text-4xl md:text-6xl font-bold mb-2 tracking-tighter">
                      たぶん <span className="border-b-4 border-emerald-300/50 pb-1">{fmt(result.count)}</span> 個
                    </div>
                    <div className="text-xl md:text-2xl font-medium opacity-80 mb-8">前後です。</div>
                    <div className="inline-block bg-black/10 rounded-lg px-6 py-3 mb-6 backdrop-blur-sm border border-white/10 text-center">
                      <div className="text-sm opacity-80 mb-1">この数のゆれ</div>
                      <div className="font-bold text-xl">±{result.errorMargin} 個 くらい</div>
                    </div>
                    <p className="text-sm opacity-70 max-w-lg mx-auto leading-relaxed border-t border-white/10 pt-4 mt-2">
                      じっくり調べたうえで、<br/>ウソをつかずに言える範囲です。
                    </p>
                  </div>
                ) : (
                  // 赤
                  <div className="bg-gradient-to-br from-rose-500 to-red-600 rounded-2xl shadow-xl p-8 text-center text-white mb-8 relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-2 bg-rose-300 opacity-30"></div>
                    <div className="flex justify-center mb-4">
                      <div className="bg-white/20 p-3 rounded-full backdrop-blur-sm">
                        <ShieldAlert className="w-8 h-8 text-white" />
                      </div>
                    </div>
                    <h2 className="text-2xl md:text-3xl font-bold mb-6">ここではあえて黙ります。</h2>
                    <div className="bg-black/20 rounded-xl p-6 md:p-8 mb-6 backdrop-blur-sm border border-white/10 mx-auto max-w-lg">
                      <p className="text-xl font-bold leading-relaxed">
                        このあたりの素数の数については、<br/>自信がないので答えません。
                      </p>
                    </div>
                    <div className="inline-flex items-center gap-2 bg-white/10 px-4 py-2 rounded-lg text-sm font-medium text-rose-100">
                      <Info className="w-4 h-4" />
                      理由：{result.reason}
                    </div>
                  </div>
                )}

                {/* 比較エリア */}
                <div className="bg-white rounded-xl border border-slate-200 p-6 mb-12">
                  <h3 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-4 text-center">ふつうの計算とのちがい</h3>
                  <div className="flex flex-col md:flex-row gap-4 items-stretch">
                    <div className="flex-1 bg-slate-100 rounded-lg p-4 text-sm text-slate-600 relative overflow-hidden">
                      <div className="absolute top-0 left-0 w-1 h-full bg-slate-400"></div>
                      <div className="font-bold mb-1 text-slate-700">ふつうの計算</div>
                      <p>どんな場所でも、とりあえず数字を出します。<br/><span className="text-xs text-slate-400">（合ってるかどうかは分かりません）</span></p>
                    </div>
                    <div className="hidden md:flex items-center justify-center text-slate-300">
                      <ArrowRight className="w-5 h-5" />
                    </div>
                    <div className="flex-1 bg-blue-50 rounded-lg p-4 text-sm text-blue-800 relative overflow-hidden">
                      <div className="absolute top-0 left-0 w-1 h-full bg-blue-500"></div>
                      <div className="font-bold mb-1 text-blue-900">このアプリ</div>
                      <p>“ここは危ない”と感じた場所では、自分から黙ります。<br/><span className="text-xs text-blue-400">（ウソをつくくらいなら答えない）</span></p>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* フッター＆隠し証明モニター */}
            <div className="border-t border-slate-200 pt-8">
               
              <button 
                onClick={() => setShowMonitor(!showMonitor)}
                className="w-full text-center text-slate-500 hover:text-emerald-600 text-sm font-medium flex items-center justify-center gap-2 transition-colors mb-4"
              >
                {showMonitor ? <ChevronUp className="w-4 h-4"/> : <Lock className="w-4 h-4" />}
                {showMonitor ? "専門的な詳細を閉じる" : "専門的な詳細（証明モニター）を開く"}
              </button>

              {/* 証明モニター（ここだけ黒背景のガチ仕様） */}
              {showMonitor && monitorState && (
                <div className="transition-all duration-300">
                  <section className="bg-slate-950 rounded-2xl border border-slate-800 overflow-hidden shadow-2xl text-slate-200 mb-8">
                    {/* ヘッダー */}
                    <div className="bg-black px-6 py-4 border-b border-slate-800 flex items-center justify-between">
                      <h2 className="text-sm font-bold text-emerald-400 flex items-center gap-2">
                        <Activity className="w-4 h-4" />
                        CERTIFICATE MONITOR
                      </h2>
                      <div className="text-[10px] font-mono text-slate-500">GD-OS Kernel v1.0.4</div>
                    </div>

                    <div className="p-6">
                      {/* バッジ表示 */}
                      <div className="flex justify-end mb-4">
                          <div className={`px-2 py-1 rounded text-xs font-mono border 
                           ${monitorState.badge.style === 'proven' ? 'bg-emerald-900/30 text-emerald-400 border-emerald-800' : 
                             monitorState.badge.style === 'heuristic' ? 'bg-indigo-900/30 text-indigo-400 border-indigo-800' : 
                             'bg-slate-800 text-slate-400 border-slate-700'}`}>
                            STATUS: {monitorState.badge.label}
                          </div>
                      </div>

                      {/* スライダーエリア */}
                      <div className="mb-8">
                        <div className="flex justify-between items-end mb-2">
                          <label className="text-xs font-bold text-slate-500">安全強度設定 (BOUNDARY)</label>
                          <span className="text-xs font-mono text-emerald-400">
                            {displayMode === 'careful' ? '慎重 (Careful)' : displayMode === 'standard' ? '標準 (Standard)' : '挑戦 (Challenge)'}
                          </span>
                        </div>
                        <div className="flex items-center gap-4">
                          <div className="flex-1 relative h-2 bg-slate-800 rounded-full">
                            <input type="range" min="0" max="2" step="1" 
                              value={displayMode === 'careful' ? 0 : displayMode === 'standard' ? 1 : 2}
                              onChange={(e) => setDisplayMode(['careful', 'standard', 'challenge'][e.target.value])}
                              className="absolute w-full h-full opacity-0 cursor-pointer z-10" />
                            <div className={`absolute h-full rounded-full transition-all duration-300
                              ${displayMode === 'careful' ? 'w-1/3 bg-emerald-600' : 
                                displayMode === 'standard' ? 'w-2/3 bg-blue-600' : 'w-full bg-orange-600'}`}></div>
                            <div className="absolute w-4 h-4 bg-white rounded-full shadow top-1/2 -translate-y-1/2 transition-all duration-300"
                              style={{ left: displayMode === 'careful' ? '16%' : displayMode === 'standard' ? '50%' : '84%' }}></div>
                          </div>
                        </div>
                        <div className="flex justify-between text-[10px] text-slate-600 mt-1 font-mono">
                          <span>慎重</span>
                          <span>標準</span>
                          <span>挑戦</span>
                        </div>
                      </div>

                      {/* 安全域バー */}
                      <div className="mb-6">
                        <div className="text-xs font-bold text-slate-500 mb-2">カバレッジ解析 (COVERAGE ANALYSIS)</div>
                        <div className="h-4 w-full flex rounded-sm overflow-hidden bg-slate-800 border border-slate-700">
                          {monitorState.relativeZones.map((z, i) => (
                            <div key={i} style={{ width: `${z.width}%` }} 
                              className={`h-full transition-all duration-500 
                                ${z.zone === 'proven' ? 'bg-emerald-500' : 
                                  z.zone === 'heuristic' ? 'bg-blue-500' : 'bg-slate-700'}`} />
                          ))}
                        </div>
                        <div className="flex flex-wrap gap-4 mt-3">
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-emerald-500"></div>
                            <span className="text-[10px] text-slate-400">証明済 (Verified)</span>
                          </div>
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-blue-500"></div>
                            <span className="text-[10px] text-slate-400">推論 (Heuristic)</span>
                          </div>
                          <div className="flex items-center gap-1.5">
                            <div className="w-2 h-2 rounded-full bg-slate-700"></div>
                            <span className="text-[10px] text-slate-500">未検証 (Unknown)</span>
                          </div>
                        </div>
                      </div>

                      {/* Σ1ログ & サマリー */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {/* メトリクス */}
                        <div className="bg-black/50 rounded-lg p-4 border border-slate-800">
                          <div className="text-xs font-bold text-slate-500 mb-3 border-b border-slate-900 pb-2">主要指標 (CORE METRICS)</div>
                          <div className="space-y-3">
                            <div className="flex justify-between items-center">
                              <span className="text-xs text-slate-400">WG 上界</span>
                              <span className="text-xs font-mono text-indigo-300">{monitorState.summary.wgBound}</span>
                            </div>
                            <div className="flex justify-between items-center">
                              <span className="text-xs text-slate-400">Positive Margin</span>
                              <span className="text-xs font-mono text-emerald-300">
                                δ ≥ {monitorState.summary.deltaPos.toPrecision(4)}
                              </span>
                            </div>
                          </div>
                           
                          {/* 数学者向け専門的注釈（ここに追加！） */}
                          <div className="mt-4 pt-3 border-t border-slate-900 text-[9px] text-slate-500 leading-relaxed font-mono">
                            ※ このモニターは、明示公式 −ζ'/ζ の有限窓版に基づく Σ₁ 型誤差帳簿です。<br/>
                            β·Z_min は prime-source の主要項で、Z_min は有限区間での数値最小値です。<br/>
                            WG/Zero/Prime/Window の各誤差 c_i は、外向き丸め上界で評価されています。<br/>
                            誤差は、(1) 有限表（零点表は T₀ まで、素数表は X₀ まで）と、(2) その先の有界積分評価（閉形式上界）で管理しています。<br/>
                            <br/>
                            主要項と誤差の差 margin = β·Z_min − ε_total が正なら、δ_pos ≥ m_hat(Δ)·margin &gt; 0 が成立し、これが「証明ゾーン」の根拠です。<br/>
                            T₀, X₀, Δ はすべて固定の有限値であり、本アプリの数値はその設定に基づく Σ₁ 証明条件の可視化に対応します。
                          </div>
                        </div>

                        {/* ログストリーム */}
                        <div className="bg-black/50 rounded-lg p-4 border border-slate-800 max-h-40 overflow-y-auto math-log">
                          <div className="text-xs font-bold text-slate-500 mb-2 sticky top-0 bg-slate-950/90 pb-2 border-b border-slate-900">Σ₁ ログ出力 (LOG STREAM)</div>
                          <div className="space-y-1 font-mono text-[10px]">
                            {monitorState.sigmaLog.map((log, i) => {
                              if (log.type === 'sep') return <div key={i} className="h-px bg-slate-800 my-2"></div>;
                              if (log.type === 'result') return (
                                <div key={i} className={`mt-2 p-1.5 rounded border ${log.success ? 'bg-emerald-900/20 border-emerald-900 text-emerald-400' : 'bg-rose-900/20 border-rose-900 text-rose-400'}`}>
                                  {log.msg}
                                </div>
                              );
                              return (
                                <div key={i} className={`flex justify-between ${log.highlight ? 'text-emerald-300 font-bold' : 'text-slate-400'}`}>
                                  <span>{log.label}</span>
                                  <span>{log.val}</span>
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      </div>
                       
                      {/* 【誠実化対応】独立性の注釈 */}
                      <div className="mt-4 text-[10px] text-slate-500 text-right leading-tight">
                        ※ 上の「自信がないので黙ります」は局所的なヒューリスティック判定であり、<br/>
                        δ_pos の Σ₁証明とは独立に動いています。
                      </div>

                    </div>
                  </section>
                </div>
              )}

              {/* 一般向け説明 */}
              <div className="bg-slate-50 rounded-xl p-6 text-sm text-slate-600 leading-relaxed">
                <p className="mb-4">
                  このアプリは、数字の世界の「ゆれ具合」を調べて、その場所でどれくらいならウソをつかずに言えるかを真剣に考えています。
                </p>
                <p className="mb-4">
                  裏側では、最新の数学アルゴリズム（決定論的ミラー・ラビン判定）を用いて、1京までの巨大な数ひとつひとつを正確にチェックしています。
                </p>
                <p className="font-bold text-slate-700">
                  大事なのは、「計算結果を出すこと」よりも、「危ないところではむしろ黙る」という態度です。
                  それが、本当に信頼できる計算機の姿だと私たちは考えています。
                </p>
              </div>

            </div>
          </div>
          <p className="text-xs text-slate-400 text-center pb-8">
            特願2025-202403号 GhostDrift 素数計算OS デモ
          </p>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PrimeCounterApp />);
  </script>
</body>
</html>
